<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An Easy How-To Guide to Slicing Lists in Python 3</title>
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        header {
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
        }
        .meta {
            color: #666;
            font-size: 0.9em;
        }
        .content {
            margin-bottom: 40px;
        }
        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #0066cc;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        nav {
            background: #f8f8f8;
            padding: 10px 0;
            margin: -20px -20px 20px -20px;
            border-bottom: 1px solid #ddd;
        }
        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            gap: 20px;
            padding: 0 20px;
        }
        nav a {
            color: #333;
            text-decoration: none;
        }
        nav a:hover {
            color: #0066cc;
        }
        .content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: 4px;
        }
        h2 {
            margin-top: 30px;
            color: #222;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
    </style>
</head>
<body>
    <nav>
        <ul>
            <li><a href="https://jessenerio.com">Home</a></li>
            <li><a href="https://jessenerio.com/publications">Publications</a></li>
            <li><a href="../../portfolio/">Portfolio</a></li>
            <li><a href="../index.html">Blog Posts</a></li>
        </ul>
    </nav>
    <header>
        <h1>An Easy How-To Guide to Slicing Lists in Python 3</h1>
        <div class="meta">
            <span>Published: January 22, 2026</span>
            <span> | Author: Jesus Guerrero</span>
        </div>
    </header>

    <article class="content">
        <p>Slicing applies to all programming languages.</p>

        <p>It is a way take a piece of a list or array and show it.</p>

        <p>Python just has a hyper intuitive way of using slices.</p>

        <p>Take a look at a Java Slice</p>

<pre>import java.util.Arrays;
import java.util.List;

public class SliceExample {
    public static void main(String[] args) {
        // Create a list of numbers
        List&lt;Integer&gt; numbersList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Convert the list to an array
        Integer[] numbersArray = numbersList.toArray(new Integer[0]);

        // Get a slice of the array
        Integer[] slicedArray = Arrays.copyOfRange(numbersArray, 2, 6);
    }
}</pre>

        <p>Looks a bit complex right? In reality it isn't all that complex, that is just Java being Java.</p>

        <p>Now take a look at a Python slice:</p>

<pre>numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbersList[2:6]</pre>

        <p>All the same, but much easier right?</p>

        <h2>Getting Index</h2>

        <p>The square brackets "[]" are a shorthand way to get the individual elements of the list.</p>

        <p>Remember, though we are using integers to represent elements in an array, we can use any datatype or class inside an array.</p>

        <p>The index number starts at 0 and represents the first element.</p>

        <p>Take a look:</p>

<pre>numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbersList[0]
# Outputs 1</pre>

        <p>If we were to take the length of an array, the last index would be that length minus 1.</p>

        <p>So for example...</p>

<pre>numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbersList[9]
#Outputs final index

len(numbersList)
#Outputs 10</pre>

        <p>If we go beyond the length of the numbersList, we get an OutOfBounds error.</p>

<pre>numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbersList[10]
# Produces OutOfBounds error and crashes</pre>

        <p>This way of measuring the length of an array with the index starting at 0 applies to all languages.</p>

        <p>In Java, Python, C++, Javascript and many more, these index rules are the standard.</p>

        <p>It is a great idea to use indexing to the point this becomes second nature.</p>

        <h2>Negative indices</h2>

        <p>Negative slices are more of a Python thing. They are extremely useful and I would not be surprised if one day they were added to other mainstream languages.</p>

        <p>The basic idea is to use a negative number to represent an approach to the array from the <em>end</em>.</p>

        <p>Take a look:</p>

<pre>numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbersList[-1]
# Outputs 10

numbersList[-2]
# Outputs 9

numbersList[-3]
# Outputs 8</pre>

        <p>We have -1 as the index being the first. This is because zero is taken up as the first element.</p>

        <p>We are choosing elements in reverse this way.</p>

        <p>If we go beyond the length again in the negative as well, we get an out of bounds:</p>

<pre>numbersList = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
numbersList[-11]
# Produces OutOfBounds error</pre>

        <p>Notice the length is one more of the actual length.</p>

        <h2>Getting Slice</h2>

        <p>The slice uses a similar approach of getting an item by index.</p>

        <p>This does apply to other languages but appears much more complex outside of Python. If you can understand the concept of slicing in Python it will be much easier to do so in other languages.</p>

        <p>Following certain rules, a slice will return another list with the elements asked for within it.</p>

        <p>Take a look</p>

        <h2>[Start:end:Step]</h2>

        <p>In a slice we have a start, end and step.</p>

        <p>Lets take a look at an example:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[3:15:2]
# Outputs new list [3, 5, 7, 9, 11, 13]</pre>

        <p>We created an array with 20 integers then sliced it into a smaller list. The smaller list is filtered according to the slicing rules.</p>

        <p>There are two thing to note in this example. Notice step. The step in the above question is 2.</p>

        <p>This means we skip 1 element as we go along the bigger array.</p>

        <p>This smaller element then has 3, 5, 7 and skips one number between each.</p>

        <p>That is a step.</p>

        <p>In addition in that code example index 15 is not included.</p>

        <p>In all programming languages whenever we are looping through elements it is standard practice to not include the final index.</p>

        <p>Lets look at another example:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[1:18:3]
# Outputs new list [1, 4, 7, 10, 13, 16]</pre>

        <p>Here we have a step of 3 and we do not include 18. In reality this is 1-17 stepping 3 times before placing an element into the list.</p>

        <h2>[::]</h2>

        <p>When slicing we can also exclude numbers and Python will default to some other value.</p>

        <p>Take a look:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[1:18]
# Outputs new list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]</pre>

        <p>We decided to not include a step in this version.</p>

        <p>By default we get a step of 1. Notice Python did not include 18.</p>

        <p>Further, start and end also have default values.</p>

        <p>Here is an example:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[:10]
# Outputs new list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</pre>

        <p>The start portion of the slice has a default of zero. We did not include it here.</p>

        <p>Remember the separating factor between start:end:step is the colon ":".</p>

        <p>Now lets see what end defaults to:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[5:]
# Outputs new list [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</pre>

        <p>Here the end defaults to the final index. From 5-19 all elements are called.</p>

        <p>What if we wanted to default all start:end:step?</p>

        <p>Take a look:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[::]
# Outputs new list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</pre>

        <p>In this case we are defaulting all parts. Steps is 1, start is 0 and end is the final index 19.</p>

        <p>We have to use the double colon because we do not have any other way to show to default the three parts.</p>

        <p>Also if we go out of bounds in a slice we just go to the limit of the list.</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[1:99]
# Outputs new list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</pre>

        <h2>Negative slices</h2>

        <p>So long as the start element of the list is to the left of the end element of the list is to the right, we can use negative slices.</p>

        <p>Take a look:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[-10:-3]
# Outputs new list [10, 11, 12, 13, 14, 15, 16]</pre>

        <p>We are referring to elements from the end but we still have to place the start to the left of end.</p>

        <p>If we reverse this order we get an empty array...</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[-3:-10]
# Outputs new list []</pre>

        <p>Steps themselves also work in the same way with negative integers.</p>

        <p>We simply take that slice and skip through it</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[-10:-3:2]
# Outputs new list [10, 12, 14, 16]</pre>

        <p>Notice negative numbers are essentially the same.</p>

        <h2>Negative stepping, [end:start:-step]</h2>

        <p>It is also possible to step in a negative direction.</p>

        <p>Essentially, reversing the list.</p>

        <p>The only problem is, when we step in the negative we also switch start and end.</p>

        <p>But, in all the cases above we can also step backward:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[15:2:-2]
# Outputs new list [15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3]</pre>

        <p>The main confusing part about this negative stepping is how we switch start and end.</p>

        <p>All rules apply above, it is just this switching that is different.</p>

        <p>We can even use the default values of a slice.</p>

        <p>Take a look:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

sliced_array = integer_array[::-1]
# Outputs new list [19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</pre>

        <p>That is how we reverse a list...</p>

        <h2>Slice object</h2>

        <p>Interestingly, there is an object which represents these slicing actions.</p>

        <p>It is known as a slice object in Python.</p>

        <p>Though this object is specific to Python, it can be used to take a portion of any list or object, depending on how that class is implemented.</p>

        <p>Take a look:</p>

<pre>integer_array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
# Create an integer array with 20 elements

my_slice = slice(3, -1, 2)

sliced_array = integer_array[my_slice]
# Outputs new list [3, 5, 7, 9, 11, 13, 15, 17]</pre>

        <p>The built-in object slice is called with the keyword slice. It initializes the exact same thing as the [start:end:step] and [end:start:-step]. But, it is created with commas and saved in a variable.</p>

        <p>This is useful when you want to re-use a slice for different lists sharing the same slices.</p>

        <h2>Slice dunder</h2>

        <p>If we want to make slicing compatible with our custom classes we have to use the double underscore to allow slices on it.</p>

        <p>Take a look at this implementation of a weather forecast:</p>

<pre>from datetime import datetime

class WeatherForecast:
    def __init__(self, date, temperatures):
        self.date = date
        self.temperatures = temperatures

    def display_forecast(self):
        print(f"Weather forecast for {self.date}:")
        for hour, temp in enumerate(self.temperatures, start=1):
            print(f"Hour {hour}: {temp}°F")

# Creating a date object for November 11, 2023
forecast_date = datetime(2023, 11, 11)

# List of temperatures per hour
hourly_temperatures = [25, 26, 24, 23, 22, 21, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 14, 14, 13, 13, 12, 12]

# Creating a WeatherForecast object
my_forecast = WeatherForecast(forecast_date, hourly_temperatures)

# Displaying the weather forecast
my_forecast.display_forecast()

'''Output
Weather forecast for 2023-11-11 00:00:00:
Hour 1: 25°F
Hour 2: 26°F
Hour 3: 24°F
Hour 4: 23°F
etc.
'''</pre>

        <p>In this example we have 24 hourly temperature reports in Fahrenheit.</p>

        <p>If we wanted to take a slice of these hourly temperatures we could do it like this:</p>

<pre># Creating a date object for November 11, 2023
forecast_date = datetime(2023, 11, 11)

# List of temperatures per hour
hourly_temperatures = [25, 26, 24, 23, 22, 21, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 14, 14, 13, 13, 12, 12]

# Creating a WeatherForecast object
my_forecast = WeatherForecast(forecast_date, hourly_temperatures)

my_forecast[1:13]
# Error, no implementation</pre>

        <p>We can take a slice of the forecast. But we get an error stating there is no implementation.</p>

        <p>So, let's implement a slice...</p>

<pre>from datetime import datetime

class WeatherForecast:
    def __init__(self, date, temperatures):
        self.date = date
        self.temperatures = temperatures

    def __getitem__(self, key):
        if isinstance(key, slice):
            # If a slice is provided, return a new WeatherForecast object with sliced temperatures
            return WeatherForecast(self.date, self.temperatures[key])
        else:
            # If a single index is provided, return the temperature at that index
            return self.temperatures[key]

    def display_forecast(self):
        print(f"Weather forecast for {self.date}:")
        for hour, temp in enumerate(self.temperatures, start=1):
            print(f"Hour {hour}: {temp}°C")</pre>

        <p>Take a look at that new __getitem__ function. It is known as a magic function.</p>

        <p>I write all about the <a href="how-the-awesome-might-of-magic-functions-works-and-is-so-simple.html">power of magic functions</a>, if you want to take a read.</p>

        <p>But basically here, we are organizing how to get indices inside a custom class.</p>

        <p>Inside __getitem()__ we check for a slice and get that portion, returning a WeatherReport.</p>

        <p>With the above we will get a returned weather report with the sliced temperatures:</p>

<pre># Example usage
if __name__ == "__main__":
    # Creating a date object for November 11, 2023
    forecast_date = datetime(2023, 11, 11)

    # List of temperatures per hour
    hourly_temperatures = [25, 26, 24, 23, 22, 21, 20, 19, 18, 18, 17, 17, 16, 16, 15, 15, 14, 14, 13, 13, 12, 12]

    # Creating a WeatherForecast object
    my_forecast = WeatherForecast(forecast_date, hourly_temperatures)

    # Using the __getitem__ method for slicing and accessing individual elements
    sliced_forecast = my_forecast[3:10]
    single_temperature = my_forecast[5]

    # Displaying the sliced forecast and a single temperature
    print("Sliced Forecast:")
    sliced_forecast.display_forecast()
    print(f"Temperature at Hour 5: {single_temperature}°C")

'''Output
Sliced Forecast:
Weather forecast for 2023-11-11 00:00:00:
Hour 1: 23°C
Hour 2: 22°C
Hour 3: 21°C
Hour 4: 20°C
Hour 5: 19°C
Hour 6: 18°C
Hour 7: 18°C
Temperature at Hour 5: 21°C
'''</pre>

        <p>I recommend asking an LLM to create get_item dunder methods whenever you need them and learn that way.</p>

        <p>It is best by examples.</p>

        <p>Anywho, I hope you learned something...</p>

        <p>CTA: Check out my other articles and follow me on medium.</p>

        <p>Happy coding!</p>

        <h2>Resources</h2>

        <p>Copy of Chat-GPT logs: <a href="https://chat.openai.com/share/51650905-6568-4ab4-8245-38572151ac7c">https://chat.openai.com/share/51650905-6568-4ab4-8245-38572151ac7c</a></p>

        <p>The power of magic functions: <a href="how-the-awesome-might-of-magic-functions-works-and-is-so-simple.html">How the Awesome Might of Magic Functions Works and Is So Simple</a></p>
    </article>

    <footer>
        <a href="../index.html" class="back-link">&larr; Back to Blog</a>
    </footer>
</body>
</html>
