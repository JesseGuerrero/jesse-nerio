<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to NodeJS: How and Why Use JavaScript's Awesome Runtime</title>
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        header {
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
        }
        .meta {
            color: #666;
            font-size: 0.9em;
        }
        .content {
            margin-bottom: 40px;
        }
        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #0066cc;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        nav {
            background: #f8f8f8;
            padding: 10px 0;
            margin: -20px -20px 20px -20px;
            border-bottom: 1px solid #ddd;
        }
        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            gap: 20px;
            padding: 0 20px;
        }
        nav a {
            color: #333;
            text-decoration: none;
        }
        nav a:hover {
            color: #0066cc;
        }
        .content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: 4px;
        }
        h2 {
            margin-top: 30px;
            color: #222;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: "Courier New", Courier, monospace;
        }
        code {
            font-family: "Courier New", Courier, monospace;
        }
    </style>
</head>
<body>
    <nav>
        <ul>
            <li><a href="https://jessenerio.com">Home</a></li>
            <li><a href="https://jessenerio.com/publications">Publications</a></li>
            <li><a href="../../portfolio/">Portfolio</a></li>
            <li><a href="../index.html">Blog Posts</a></li>
        </ul>
    </nav>
    <header>
        <h1>Introduction to NodeJS: How and Why Use JavaScript's Awesome Runtime</h1>
        <div class="meta"></div>
    </header>

    <article class="content">
        <p>Node is a runtime for JavaScript. Think like Java JRE, .NET Runtime or the Python runtime. These include the compiler, standard libraries and middle ware between the language and the OS.</p>

        <p>Not all languages include a complete runtime. For example-once you put together a C++ runtime it works for that specific system. C and C++ have various compilers and language implementations which work only for a specific OS or platform.</p>

        <p>Node, Python and Java JRE runtimes are cross-platform and once installed work on all systems. They are a central software that converts programming language to machine code in execution.</p>

        <p>Developers love Node's for its many features of the runtime. We programmers love Node for its cross-platform ability, package installation, ease of installation and ecosystem.</p>

        <img src="../images/nodejs-intro-img-0.png" alt="Javascript code">

        <p>When we think <em>Node</em> think <strong>a way to run JavaScript in machine code</strong>.</p>

        <h2>Google V8 Engine history</h2>

        <p>In a distant past 2009-the original Node developer Ryan Dahl wanted a way to run JavaScript as machine code outside the browser. He was searching for a way to put together a runtime.</p>

        <p>He needed a compiler, executor, libraries, bindings to the OS and many features. The most important and famous part of this development is the compiler and executor. To this day we consider it so important it is the most famous part of Node.</p>

        <p>Ryan decided to include a existing compiler and executor for JavaScript-used in internet browsers. The engine converts JavaScript language to machine code then runs it.</p>

        <p>At the time there were many engines running and compiling JavaScript in the browser. SpiderMonkey, Rhino, Nitro, KJS and Google's V8 engine were used across the various browsers of the time. Nitro was used by Safari, SpiderMonkey by Fire Fox, V8 by Chrome, etc. Each was implemented differently and most in Java or C++.</p>

        <img src="../images/nodejs-intro-img-1.png" alt="V8 Engine website">

        <p>Among the engines existing in 2009 he decided on Google's V8 engine. V8 had been used across devices in Chrome for the past year. He chose the engine based on its superior performance in C++.</p>

        <p>With the engine he put together a cross-platform runtime and since 2009 Node has been built for JavaScript. Node has become the standard platform for developing Javascript.</p>

        <p>From Ryan's project we have package installation, cross-platform coding and single threaded applications with asynchronous I/O.</p>

        <h2>Node use cases</h2>

        <p>Node' asynchronous and single-threaded nature work well for certain tasks-it is good for web servers, I/O applications, APIs, general programming, page applications and video/sound streaming.</p>

        <p>It is not good for multi-threaded applications, intense CPU tasks, Desktop applications and heavy server applications like multi-core software.</p>

        <h2>Typescript</h2>

        <p>A major use case of Node is its library for Typescript. Typescript is a language wrapper for JavaScript. It is compiled down to JavaScript (in Node) then run by Node again.</p>

        <img src="../images/nodejs-intro-img-2.png" alt="TypeScript website">

        <p>Nowadays programmers use this language wrapper to make JavaScript more readable with <em>typing</em>.</p>

        <p>JavaScript is known for being easy to write but hard to read. Why? Because it does not enforce writing the type. It is typeless.</p>

        <p>Look at this:</p>

<pre>function sum(a, b) {
    return a + b;
}

let result = sum(5, 10);
console.log(result);  // Output: 15

let anotherResult = sum("5", "10");
console.log(anotherResult);  // Output: "510"</pre>

        <p>Notice two different types are used in the same function and produce a different result.</p>

        <p>Though this is great for writing a lot of code, very fast. The code becomes more illegible as the code base grows. This is why Typescript is so popular.</p>

        <p>Let's look at the same example in TypeScript:</p>

<pre>function sum(a: number, b: number): number {
    return a + b;
}

let result = sum(5, 10);
console.log(result);  // Output: 15

// Error here
let anotherResult = sum("5", "10"); //Type requires number
console.log(anotherResult);</pre>

        <p>In the function header we require numbers. From the called sum function we cannot use strings. Though our code size gets bigger we gain a substantial difference to legibility.</p>

        <p><strong>For Typescript the increased code size is worth the legibility.</strong></p>

        <p>Not only can Node run Typescript-it also loses no performance in its runtime.</p>

        <h2>JavaScript language server</h2>

        <p>Other companies and developers create language servers for various languages. <em>The Node runtime does not include a language server</em>.</p>

        <p>A language server is a backend web server which allows for autocomplete, syntax correct, find all, replacing, debugging and many more things <em>done in the editor</em>.</p>

        <img src="../images/nodejs-intro-img-3.png" alt="VS Code website">

        <p>IDE developers include it in their editor like Jetbrains or VS Code. JavaScript/Typescript developers use the IDE, runtime, language server and many other tools to develop JavaScript projects.</p>

        <h2>How to build projects</h2>

        <p>There are some notable features coders use in Node. They are NPM, Yarn, packages and the build folder. If we understand these components then we can easily understand Node.</p>

        <h2>NPM</h2>

        <p>Node Package Manager allows you to install JavaScript libraries easily with simple commands like these:</p>

<pre>npm init // Creates an NPM Node project
npm install express</pre>

        <p>NPM is an API, requiring internet to install libraries from an online repository called the <em>NPM registry</em>.</p>

        <p>The official website is npmjs.com...</p>

        <img src="../images/nodejs-intro-img-4.png" alt="NPM website">

        <p>You can pull any package on that website from NPM. JavaScript developers can publish libraries on NPM as public or private. Entire NPM library repositories can be made private or public and us consumers of the library can include them in NPM given the right credentials.</p>

        <p>To include private repositories we would use a command like so...</p>

<pre>npm config set registry https://username:password@example.com/npm</pre>

        <p>We set a registry using NPM but replace the username and password. If we wanted to publish a package in a registry we would use...</p>

<pre>npm publish
## or
npm publish --registry=https://example.com/mycompany-registry</pre>

        <p>You can use one registry at a time.</p>

        <h2>Local Vs Global</h2>

        <p>With NPM we can install libraries either in our local project or across all projects. When we include it only in one project it is called local and when we include it with Node itself it is called global.</p>

        <p>Whenever we use that specific Node software on our computer we use all the libraries globally and on our local project.</p>

        <p>Typically Node places all its global libraries in one folder on your machine.</p>

<pre>## Linux/Mac
/usr/local/lib/node_modules

## Windows
%AppData%\npm\node_modules</pre>

        <p>The name Node uses is always <strong>node_modules.</strong> When using NPM there will be a local node_modules and a public node modules.</p>

        <p>Take a look...</p>

        <img src="../images/nodejs-intro-img-5.png" alt="My local project">

        <p>Notice my local project "my-app". All libraries I install will be placed here. If I install a library globally then it will go to Node's node_modules.</p>

        <p>When I finally run the application both the local and global libraries are used. This means any global library in all of my local projects.</p>

        <p>We can run an entire node project with only the global libraries if we wanted.</p>

        <p>Here is how you can install global libraries...</p>

<pre>npm install -g express</pre>

        <p>With this command you install express in the global node_modules and make the library not needed in the local node_modules.</p>

        <h2>package.json</h2>

        <p>With package.json NPM tracks installed libraries. Here is a tiny example of a package.json.</p>

<pre>{
  "name": "my-express-app",
  "version": "1.0.0",
  "description": "A simple Express.js application",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "express": "^4.17.1"
  }
}</pre>

        <p>We have named our application, declared a version of our application along with a description of the application. In the package.json we noted the main function.</p>

        <p>The scripts are direct mappings of a command to a script. This allows for automation, take a look....</p>

<pre>npm run &lt;script&gt;
## Meaning
npm run start
## Meaning
node index.js</pre>

        <p>We run node index.js using the start command in NPM. Package.json reverses the node app down to the main function and voila our app runs...</p>

        <p>Lastly we have dependencies. Here we show the library name and its version. We can change the version or add libraries here then run npm install...</p>

<pre>npm install</pre>

        <p>npm install searches the package.json and re-installs the local node_modules depending on package.json.</p>

        <p>In between package.json and node_modules is npm install. In the end the application uses the node_modules to run in Node.</p>

        <h2>package-lock.json</h2>

        <p>We include package-lock.json to specify the exact versions of libraries to that project. Often when we change versions of our libraries we need to delete package-lock.json due to how it specifies the project.</p>

        <p>NPM creates a new package-lock.json on npm install.</p>

        <h2>Yarn</h2>

        <p>Yarn is an improved version of NPM using the same command structure and registry. It is faster and includes more features allowing it to outperform NPM.</p>

        <p>Commands include...</p>

<pre>yarn init
yarn add express
yarn remove express
yarn run &lt;script&gt;
## More</pre>

        <p>We use Yarn to improve our development while keeping the workflow the same.</p>

        <p>Anywho, I hope you learned something...</p>

        <!-- Link removed: https://a.co/d/b56kpK9 returned 404 Not Found -->
        <p>CTA: Check out my book on learning code</p>

        <p>Happy coding!</p>

        <h2>Resources</h2>

        <p>Introduction to MongoDB: <a href="https://jessenerio.com/blog/posts/a-tasty-guide-to-mongodb-discover-why-this-database-is-a-game-changer">A Tasty Guide to MongoDB</a></p>

        <p>What is an API: <a href="https://jessenerio.com/blog/posts/how-an-api-works-and-why-they-are-so-cool">How an API Works and Why They Are So Cool</a></p>
    </article>

    <footer>
        <a href="../index.html" class="back-link">&larr; Back to Blog</a>
    </footer>
</body>
</html>
