<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Why Space Complexity Is Important and How You Should Use It</title>
    <style>
        body {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
        }
        header {
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 2em;
        }
        .meta {
            color: #666;
            font-size: 0.9em;
        }
        .content {
            margin-bottom: 40px;
        }
        .back-link {
            display: inline-block;
            margin-top: 20px;
            color: #0066cc;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
        }
        nav {
            background: #f8f8f8;
            padding: 10px 0;
            margin: -20px -20px 20px -20px;
            border-bottom: 1px solid #ddd;
        }
        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            gap: 20px;
            padding: 0 20px;
        }
        nav a {
            color: #333;
            text-decoration: none;
        }
        nav a:hover {
            color: #0066cc;
        }
        .content img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: 4px;
        }
        h2 {
            margin-top: 30px;
            color: #222;
        }
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            line-height: 1.4;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        ul {
            margin: 15px 0;
            padding-left: 30px;
        }
        ol {
            margin: 15px 0;
            padding-left: 30px;
        }
    </style>
</head>
<body>
    <nav>
        <ul>
            <li><a href="https://jessenerio.com">Home</a></li>
            <li><a href="https://jessenerio.com/publications">Publications</a></li>
            <li><a href="../../portfolio/">Portfolio</a></li>
            <li><a href="../index.html">Blog Posts</a></li>
        </ul>
    </nav>
    <header>
        <h1>Why Space Complexity Is Important and How You Should Use It</h1>
        <div class="meta"></div>
    </header>

    <article class="content">
        <p>Estimating complexity is an essential part of programming.</p>

        <p>It is how we value our code as we write it.</p>

        <p>It is how we determine if it is good code or bad code.</p>

        <p>The quality of our code can be separated in 4 parts...</p>

        <ol>
            <li>Code maintainability</li>
            <li>Code size</li>
            <li>Space complexity</li>
            <li>Time complexity</li>
        </ol>

        <p>Given our solution is the same, these 4 metrics determine our code quality.</p>

        <p>By learning the theory behind each type of complexity we are meant to improve our intuition and write better performant code.</p>

        <p>The algorithm behind your code is valued by all 4.</p>

        <p>Besides maintainability and code size, we can focus on how algorithms use memory. This is known as space complexity.</p>

        <p>Space complexity is a measurement of memory in code.</p>

        <img src="../images/why-space-complexity-is-important-and-how-you-should-use-it---img-0.jpeg" alt="RAM memory modules">

        <p>This type of memory is stored while the code is running. We do not open up a Task Manager and check the RAM usage. That is not space complexity. Though, it is a surefire way to really check memory.</p>

        <p>Instead it is an internal calculation we make as programmers while coding. An estimation as to how much memory the code will take in a particular section of the code base.</p>

        <p>As we learn space and time complexity we are meant to learn every formula and when our code matches that case.</p>

        <p>All these formulas will have use cases in your future programming.</p>

        <p>They are...</p>

        <ul>
            <li>f(m)</li>
            <li>f(m*n)</li>
            <li>f(n^m)</li>
            <li>f(log(n)</li>
            <li>f(n!)</li>
            <li>f(m^n)</li>
            <li>f(n!)</li>
        </ul>

        <p>What this represents is how the algorithm in your code takes up memory.</p>

        <p>Let's take a look at some code examples:</p>

        <h2>f(m)</h2>

<pre>def fOfM():
    string = "hey"
    print(string)

fOfM()</pre>

        <p>Notice we just save a string and then print it.</p>

        <p>There are no loops, just a direct piece of memory allocated and used.</p>

        <p>Now lets look at f(n)</p>

        <h2>f(n)</h2>

<pre>def f(n):
    nums = []
    for i in range(n):
        nums.append(i) #This is the memory taker
    return sum(nums)

f(15)</pre>

        <p>Notice in this function we append a number to nums. Because of this we are taking n space. The bigger the n the bigger the memory space we take.</p>

        <p>This is a memory complexity of f(n) because our memory scales to n.</p>

        <p>If you looked at this python script in RAM in your task manager you should notice it takes more memory than f(1).</p>

        <p>The bigger the f function outputs due to n the more RAM it will take. Meaning more space is more RAM.</p>

        <p>Now lets look at f(n^m)...</p>

        <h2>f(n^m)</h2>

<pre>def populate2DArray(n, n2): #f(n^2)
    arr= []
    for x in range(n):
        arr.append([])
        for y in range(n2):
            arr[x].append(y) #This is the memory taker
    return arr

def populate3DArray(n, n2, n3): # f(n^3)
    arr= []
    for x in range(n):
        arr.append([])
        for y in range(n2):
            arr[x].append([])
            for z in range(n3):
                arr[x][y].append(y) #This is the memory taker
    return arr

populate2DArray(5, 4)
populate3DArray(3, 4, 5)</pre>

        <p>Take a look at these two functions.</p>

        <p>This is used a LOT in programming, don't think its not. This is very important in instinctively thinking about memory space.</p>

        <p>n, n2 and n3 are the three n's in f(n*n*n) or f(n^3).</p>

        <p>When we populate a 2D array we get f(n^2) memory complexity. This means as n increases we get an exponential growth in the size of our algorithm.</p>

        <p>As n increases we get more RAM usage.</p>

        <img src="../images/why-space-complexity-is-important-and-how-you-should-use-it---img-1.png" alt="Exponential vs Linear Growth graph">

        <p>Now lets look at f(log(n))</p>

        <h2>f(log(n))</h2>

<pre>n = 10
checkedElements = []
def binary_search(arr, low, high, target):
    global checkedElements
    if high >= low:
        mid = low + (high - low) // 2
        checkedElements.append(mid) # memory taker
        if arr[mid] == target:
            return checkedElements
        elif arr[mid] > target:
            return binary_search(arr, low, mid - 1, target) # recursive
        else:
            return binary_search(arr, mid + 1, high, target)
    else:
        return checkedElements

arr = [list(range(n))]
target = 4
result = binary_search(arr, 0, n - 1, target)
print(result)</pre>

        <p>Another way to think of this is f(log(n)) = space complexity.</p>

        <p>If we extend that to a different math it looks like 2^space complexity = n.</p>

        <p>What makes this work is the recursive calls. We divide the entire array in 2 every time we recursively call the function binary_search.</p>

        <p>This is used more than you think.</p>

        <p>A great way to practice estimating log(n) algorithms is to do LeetCode.</p>

        <p>There are specific problems on the platform which require you to solve an log(n) algorithm.</p>

        <p>If all this feels too much right now, its okay. It is hard on everyone that starts on this. I think once we get past f(n^2) in complexity it starts to get tough to implement.</p>

        <p>As you solve problems, particularly LeetCode, you easily start being able to categorizing every algorithm you ever make into these f(n) functions.</p>

        <p>Now lets look at our final f(n) function...</p>

        <h2>f(m^n)</h2>

<pre>n=5
def get_subsets(set):
    if not set:
        return [[]]

    subsets = []
    first_element = set[0]
    remaining_subsets = get_subsets(set[1:])

    for subset in remaining_subsets:
        subsets.append(subset)
        subsets.append([first_element] + subset)

    return subsets

my_set = [list(range(n))]
subsets = get_subsets(my_set)
print(f"All subsets of {my_set} are:")
for subset in subsets:
    print(subset)</pre>

        <p>In this function we get every combination of elements possible.</p>

        <p>For every element we add to the set we double the number of combinations.</p>

        <p>There are 1 combination in [], 2 combinations in [1] they are [], [1] and 4 combinations in [1, 2] they are [], [1], [2], [1, 2]. As we increase n we get f(2^n) because of this doubling.</p>

        <p>For specific algorithms, specifically where we need combinations or previous numbers in recursion we get f(2^n)</p>

        <h2>How we are meant to check complexity</h2>

        <p>It would be tedious to check our RAM for every algorithm we ever write.</p>

        <p>We are not meant to check that way. Instead we do it intuitively using the 6 types of complexities above.</p>

        <p>We estimate it in our heads and deem the program performant or not performant based on our reading of the code.</p>

        <p>LeetCode is amazing for learning to control the complexity of your algorithms. You are meant to completely write out a code problem and its complexity without ever running it or checking print statements.</p>

        <p>At the very end you run the code problem. The platform directly measures the memory and run-time and tells you if all the complexity measurements you did in your head were correct.</p>

        <p>LeetCode specifically asks you to create certain f(n) algorithms. So you need to deliberately craft your code to perform at that complexity.</p>

        <p>Your goal on the platform is to craft the lowest f(n) code possible.</p>

        <p>At first this is extremely difficult. What is crazy, your mind will adapt to estimating complexity. It is a learned trait which you gain by practicing daily. After a few weeks it gets easier and easier. Eventually it becomes second nature as you code and you use it all the time, writing more performant code.</p>

        <h2>The 3 notations of complexity Omega, Theta, O</h2>

        <p>Using our f(n) functions there are three types of bounds for our space complexity.</p>

        <p>They are the best case, the middle case and the worst case.</p>

        <p>Let's look at f(2^n) and see what these cases are...</p>

<pre>n=5
def get_subsets(set):
    if not set: #Best case f(1)
        return [[]]

    subsets = []
    first_element = set[0]
    remaining_subsets = get_subsets(set[1:])

    for subset in remaining_subsets:
        subsets.append(subset)
        subsets.append([first_element] + subset)

    return subsets

my_set = [list(range(n))]
subsets = get_subsets(my_set) # worst case f(2^n)
print(f"All subsets of {my_set} are:")
for subset in subsets:
    print(subset)</pre>

        <p>Notice the top of the get_subsets function. It says return [[]]. This means we did no memory allocation.</p>

        <p>This makes our best case f(1). Our middle case is anything between the worst case and the best case.</p>

        <img src="../images/why-space-complexity-is-important-and-how-you-should-use-it---img-2.png" alt="Algorithm complexity graph showing N^2, N, log N, and 1">

        <p>All functions between f(1) and f(2^n) are middle cases.</p>

        <p>This means anything from f(1) to f(2^n) like f(log(n)), f(n) or f(n^2) are all middle cases.</p>

        <p>Finally, the worst case is f(2^n).</p>

        <p>Of these 3 cases; best, middle, worst we call them Omega (best), Theta (middle) and O (worst).</p>

        <p>The are pronounced big Omega, big Theta and big Oh.</p>

        <p>All three of these are meant to be calculated in our heads all at once. We are supposed to think of every edge case, estimating the best, middle and worst.</p>

        <h2>Why is there a trade off between space and time?</h2>

        <p>When doing these calculations in your head you should eventually notice a trend.</p>

        <img src="../images/why-space-complexity-is-important-and-how-you-should-use-it---img-3.jpeg" alt="Person relaxing at desk">

        <p>As you decrease space complexity you get more time complexity.</p>

        <p>And as you increase space complexity you decrease time complexity.</p>

        <p>This is a phenomena in programming simply known as the space-time trade-off.</p>

        <p>If you can find a way to reduce both space and time then you have discovered a superior algorithm.</p>

        <p>But within similar complexities you will see a trade off.</p>

        <p>It exists due to how the resources are used. If more things are in memory then we reduce the need for processing them in run-time.</p>

        <p>If we didn't save it to memory then all the calculations have to be done to them in real-time.</p>

        <p>Well, that pretty much sums up space complexity. I hope you use it in all that you do...</p>

        <p>Anywho, I hope you learned something...</p>

        <!-- Link removed: https://a.co/d/b56kpK9 returned 404 Not Found -->
        <p>Check out my book on learning code!</p>

        <p>Happy coding!</p>
    </article>

    <footer>
        <a href="../index.html" class="back-link">&larr; Back to Blog</a>
    </footer>
</body>
</html>
